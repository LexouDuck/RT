/* ************************************************************************** */
/*                                                                            */
/*                                                        :::      ::::::::   */
/*   cone.c                                             :+:      :+:    :+:   */
/*                                                    +:+ +:+         +:+     */
/*   By: fulguritude <marvin@42.fr>                 +#+  +:+       +#+        */
/*                                                +#+#+#+#+#+   +#+           */
/*   Created: 2018/09/27 19:23:31 by fulguritu         #+#    #+#             */
/*   Updated: 2018/10/06 12:52:59 by fulguritu        ###   ########.fr       */
/*                                                                            */
/* ************************************************************************** */

#include "rtv1.h"

/*
** Returns the dot product where the y component is prescaled by
**	i = sqrt(-1) in both inputs; useful for solving x^2 + z^2 == y^2, as the
**	kernel of this function is the solution
*/

static inline t_float	vec3_yneg_dot(t_vec_3d const v1, t_vec_3d const v2)
{
	return (v1[0] * v2[0] - v1[1] * v2[1] + v1[2] * v2[2]);
}

/*
** The infcone primitive is the set of points made up by all rotations around
** the y axis of the subspace (here, line) generated by the vector (1., 1., 0.).
**
** Any point on this primitive verifies x^2 + z^2 == y^2; thus one must find
**	r = o + td
**	(o+td)_x^2 + (o+td)_z^2 - (o+td)_y^2			== 0		<=>
**
**	(ox + t dx)^2 + (oz + t dz)^2 - (oy + t dy)^2	== 0		<=>
**
**	(ox^2 + oz^2 - oy^2)				+						<=>
**	2 * (oxdx + ozdz - oydy)	* t		+
**	(dx^2 + dz^2 - dy^2)		* t^2				== 0
*/

t_bool					intersect_ray_infcone(t_ray *objray)
{
	t_vec_3d	quadpoly;
	t_float		root1;
	t_float		root2;

	quadpoly[0] = vec3_yneg_dot(objray->dir, objray->dir);
	quadpoly[1] = 2 * vec3_yneg_dot(objray->dir, objray->pos);
	quadpoly[2] = vec3_yneg_dot(objray->pos, objray->pos);
	if (!(get_realroots_quadpoly(&root1, &root2, quadpoly)))
		return (FALSE);
	if (root1 <= 0. && root2 <= 0.)
		return (FALSE);
	if (root1 <= 0.)
		root1 = root2;
	else if (root2 <= 0.)
		root2 = root1;
	if (root1 > objray->t && root2 > objray->t)
		return (FALSE);
	if ((objray->dir[1] * root1 + objray->pos[1]) *
		(objray->dir[1] * root2 + objray->pos[1]) >= 0.)
		objray->t = ft_fmin(root1, root2);
	else
		objray->t = ft_fmax(root1, root2);
	return (TRUE);
}

/*
** The cone primitive is an infcone from 0. to 1. on the y axis, and a circle
** of radius one, in the affine plane "xz + (0, 1, 0)" and centered in (0,1,0).
**
** This means the position of the cone in world space should coincide with
** the point of the cone.
*/

t_bool					intersect_ray_cone(t_ray *objray)
{
	t_ray		tmp_ray;
	t_float		tmp;
	t_bool		is_in_infcone;
	t_bool		is_in_hrz_area;

	if ((is_in_infcone = (vec3_yneg_dot(objray->pos, objray->pos) <= 0) &&
		(is_in_hrz_area = (0. <= objray->pos[1] && objray->pos[1] <= 1.))))
		return (FALSE);
	tmp = 1. / 0.;
	tmp_ray = *objray;
	if (intersect_ray_infcone(&tmp_ray))
	{
		tmp = tmp_ray.pos[1] + tmp_ray.t * tmp_ray.dir[1];
		tmp = 0. < tmp && tmp < 1. ? tmp_ray.t : 1. / 0.;
	}
	tmp_ray.t = objray->t;
	tmp_ray.pos[1] -= 1.;
	if (objray->pos[1] > 1. && intersect_ray_disk(&tmp_ray))
		tmp = ft_fmin(tmp, tmp_ray.t);
	objray->t = ft_fmin(tmp, objray->t);
	return (objray->t == tmp);
}

/*
** Notice that if one reflects hitpos over the xz-plane, one obtains a scaled
**	version of the normal at hitpos.
*/

void					get_hnn_infcone(t_vec_3d hitpos, t_vec_3d normal,
									t_ray const objray)
{
	get_ray_hitpos(hitpos, objray);
	vec3_set(normal, hitpos[0], -hitpos[1], hitpos[2]);
	vec3_eucl_nrmlz(normal, normal);
}

void					get_hnn_cone(t_vec_3d hitpos, t_vec_3d normal,
									t_ray const objray)
{
	get_ray_hitpos(hitpos, objray);
	if (ft_fabs(hitpos[1] - 1) < APPROX)
	{
		vec3_set(normal, 0, 1., 0.);
	}
	else
	{
		vec3_set(normal, hitpos[0], -hitpos[1], hitpos[2]);
		vec3_eucl_nrmlz(normal, normal);
	}
}
