/* ************************************************************************** */
/*                                                                            */
/*                                                        :::      ::::::::   */
/*   rt_cl_hyperboloid.cl                               :+:      :+:    :+:   */
/*                                                    +:+ +:+         +:+     */
/*   By: duquesne <marvin@42.com>                   +#+  +:+       +#+        */
/*                                                +#+#+#+#+#+   +#+           */
/*   Created: 2006/06/06 06:06:06 by duquesne          #+#    #+#             */
/*   Updated: 2006/06/06 06:06:06 by duquesne         ###   ########.fr       */
/*                                                                            */
/* ************************************************************************** */

/*
** The hyperboloid primitive is the set of points made up by all rotations around
** the y axis of the subspace (here, line) generated by the vector (1., 1., 0.).
**
** Any point on this primitive verifies x^2 + z^2 == y^2 + 1; thus one must find
**	r = o + td
**	(o+td)_x^2 + (o+td)_z^2 - (o+td)_y^2			== 0		<=>
**
**	(ox + t dx)^2 + (oz + t dz)^2 - (oy + t dy)^2	== 0		<=>
**
**	(ox^2 + oz^2 - oy^2) - 1			+						<=>
**	2 * (oxdx + ozdz - oydy)	* t		+
**	(dx^2 + dz^2 - dy^2)		* t^2				== 0
*/

static t_intersection		rt_cl_hyperboloid_intersect
(
							float *		res,
							t_ray		ray
)
{
	float3 			quadpoly;
	float2			roots;
	bool			is_inside_hyperbola;

	quadpoly.x = rt_cl_float3_yneg_dot(ray.dir, ray.dir);
	quadpoly.y = 2.f * rt_cl_float3_yneg_dot(ray.dir, ray.pos);
	quadpoly.z = rt_cl_float3_yneg_dot(ray.pos, ray.pos) - 1.f;
	if(!(rt_cl_get_realroots_quadpoly(&roots, quadpoly)))
		return (INTER_NONE);
	if (roots.x <= 0.f && roots.y <= 0.f)
		return (INTER_NONE);
	is_inside_hyperbola = quadpoly.z <= 0.f;
	if (roots.x <= 0.f)
	{
		*res = roots.y;
		return (is_inside_hyperbola ? INTER_INSIDE : INTER_OUTSIDE);
	}
	else if (roots.y <= 0.f)
	{
		*res = roots.x;
		return (is_inside_hyperbola ? INTER_INSIDE : INTER_OUTSIDE);
	}
	*res = fmin(roots.x, roots.y);
	return (is_inside_hyperbola ? INTER_INSIDE : INTER_OUTSIDE);
}

/*
** Notice that if one reflects hitpos over the xz-plane, one obtains a scaled
**	version of the normal at hitpos.
*/

static float3			rt_cl_hyperboloid_get_normal
(
						float3 hitpos
)
{
	float3 	normal;

	normal = (float3)(hitpos.x, -hitpos.y, hitpos.z);	
	normal = normalize(normal);

	return (normal);
}