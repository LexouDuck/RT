Getting a ray's direction from the FOV angle:
	x = j - W/2
	y = i - H/2
	z = -W/(2*tan(FOV/2))
=> FOV is the angle centered on the camera, and that spans 0 to width - 1
	horizontally.
=> this formula produces the vectors for a camera facing from +z to -z, positive
x on the right, and positive y towards the bottom


I) Lighting effects

Lambertian 'diffuse' lighting model:

A contact point on a sphere is lighted according to the formula 
	(albedo * light_intensity * <N, L>)/ (PI * quaddist(contact, light_spot))

-where albedo is an coefficient between 0 and 1 defining how much light is
	reflected, and you generally (for physical realism) divide the albedo
	by PI, hence the pi in the formula
-where N is the unit normal on the object at the contact point
-where L is the unit vector from contact to light_spot)

Object shadows on other objects:
-send a ray from the current contact point being studied (we want its color) to
each light source. If the ray thus created is blocked [ie, d(contact, light) >
d(contact, new_contact)], then darken the point, as it is in shadow.
NB: little trick is to use contact + 0.01 * normal rather than contact, as this
might help avoid noise due to float imprecision


Mirror objects:
-send a light ray, cast only the reflected ray; obtained by the formula:
 v_reflected = v_incident - 2 * dot(v_incident, normal) * normal


Transparent objects:
- every transparent object should have a refraction index (air is 1.)
- every ray has a normal and a tangential componenent so that normal +
	tangential (scaled appropriately) = ray; this is fundamental when building
	a transparency ray 
- T = T_t + T_n, as explained
- T_t = n_i / n_t * (incident - vec3_scl(dot(incident, normal), normal) with n_i
	and n_t the refraction index of the incident milieu and the transparent
	milieu respectively
- T_n = vec3_scale(coef, normal) with coef = -sqrt(1 - (n_i/n_t)² * (1 -
		dot(incident, normal)²)). NB the number inside the square root can be
		negative, in which case the ray is not refracted but reflected


https://fr.wikipedia.org/wiki/Brillant_et_mat


Shadows cast by transparent objects and mirror must be treated differently.


II) Intersection

A ray is defined by R = pos_origin + t * dir; where dir is a unit vector, t is
	a positive real number which acts as a parameter, and pos_origin is the
	point from where the ray is cast.
	Note that since t is +inf and only decreases, R(t) = cur_endpoint_of_ray for
	a chosen t.

Sphere/ray intersection
	't' is the parameter that allows one to know where on the line
		generated by a ray they are.
	'center' is the sphere's center
	'radius' its radius

formula in world space : 						t^2 +
						2*<dir,origin - center> * t +
						quadnorm(origin - center) - radius^2 == 0
formula in object space : quadnorm(objray->dir) * t^2 +
						2 * <dir,origin - center> * t +
						quadnorm(origin - center) - radius^2 == 0

roots of the polynomial exist iff there is intersection (so use the
discriminant of a degree 2 polynomial), and these roots (t1 and t2) are
negative iff the object is behind the camera origin. If the roots are of
opposite sign to each other, then the camera/ray origin is located inside the
sphere.
