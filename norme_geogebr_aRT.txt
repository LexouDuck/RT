Je compte envoyer cela à la pédago:

Bonjour, j'ai plusieurs questions concernant la possibilité de choisir notre propre norme:

1) A partir de quand cela sera-t-il mis en place ?
2) On se chauffe pour un RT assez dément (cross-platform Win/Lin/Mac, UX pédago, espaces non-eucliden formalisés en géométrie algébrique plutôt qu'algèbre linéaire, motion design, module pour générer des fractales de dimension n, OpenCL) qu'on puisse utiliser hors 42. On a besoin d'un peu plus de libertés du coup, mais on veut un truc sérieux et très propre. On a réfléchit et on s'est renseigné, on se demandait si la norme suivante convient: 



I) Style général et contrôle qualité

 - Qualité "lint free" assurée avec AdLint + compilation avec les flags usuels (-Wall -Werror -Wextra) et -O2/O3 selon le meilleur rendu final (ça peut être platform-dependent).

 - style de structuration du namespace façon SDL (dont on se sert) pour mieux diviser nos différents modules en restant cohérent dans l'ensemble (notamment ft_ en FT_ dans le style SDL_ pour signaler le standard recodé :wink:). Le prototype de base est MODULE_GroupeDeFonction_GroupeVerbalExpliquantLActionDeLaFonction();. Des libertés sont autorisée si la partie '_GroupeDeFonction_' rajoute inutilement du détail pour des fonctions utilitaires au rôle évident, comme celles du standard recodé. Un exemple: on peut préférer "FT_IsAlpha()" plutôt que "FT_Char_IsAlpha()" si on a un sous-module "libft_char.h" dans notre libft).

 - PascalCase pour globales et noms de fonction; lowercase pour noms de variables et arguments. 

 - Usage d’underscores pour séparer les modules et sous-modules/groupes de fonction dans le nom des fonctions. Usage d’underscores uniquement pour soulever une ambiguïté ou améliorer la lecture dans un nom de variable locale ou globale.

 - Toute utilisation de globale doit être justifiée par un commentaire dans le .h où celle-ci est définie. Interdiction de définir une globale dans un .c. Les globales seront précédées du préfixe ‘GBL_’, comme si elles appartenaient à un "module des globales", plutôt qu'au module correspondant au .h dans lequel chacune est définie. Si la logique du code le demande, il peut être légitime de créer un fichier "XX_globals.h" dans lequel on gère la définition des globales. Par exemple si on implémente comme globales plusieurs tableaux de pointeurs sur fonctions d'interruption et que ceux-ci méritent leur propre petit module.

 - Toute sortie du programme sera accompagnée d’un message d’erreur spécifiant l’erreur et l’endroit du code (le nom de la fonction) l’ayant générée.

 - Aucun caractère non-ASCII standard sauf éventuellement dans un commentaire.

 - Noms judicieux pour toute entité du code (lisibles, compréhensibles, expressifs, mnémoniques, et cohérents entre eux (pas de ‘str’ quelque part, et ‘strg’ autre part pour le même concept de “(char*) en tant que string”). 

 - Tous les noms de variable, de fonction, de module et tous les commentaires seront en anglais. En bref, l'intégralité du code source sera en anglais.

 - Une ligne vide n’aura ni espace, ni tabulation. Maximum de 80 caractères de taille 1 par ligne. Tabulation taille 4. Pas de whitespace en fin de ligne. Global scope alignment.

 - Tout groupe d'étoiles de pointeurs employé dans une déclaration de type ('*', '**', '***', ...) sera entourés d'espaces blancs, sauf s'il est suivi à la place d'une tabulation. Toute * de pointeur sera considérée comme faisant partie du type auquel elle renvoie. La tabulation s’adaptera à cette vision des types (on tabulera “char **	str” et pas “char	**str” lors des déclarations; “char * str” plutôt que “char *str” en argument de fonction, etc).

 - Tout argument traité comme read-only dans la logique du code utilisera le qualificateur 'const' de manière appropriée.

 - La convention de lecture des qualifiers 'const' de droite à gauche sera employée. Par exemple, "char const * const str" signifie que "str is a constant pointer to an array of constant characters". Cette lecture dans le sens "inverse", et s'efforcer de coder pour, rend l'usage du 'const' intuitif. Avoir un 'const' tout à gauche d'une déclaration d'argument est donc interdit. Tout qualificateur 'const' sera entouré de deux espaces vides.

 - Toute déclaration de type dans laquelle le qualificateur 'const' intervient forcera à entourer les groupes d'étoiles '*' de deux espaces. Cela s'applique aux signatures de fonction dans les .h et dans les .c. Exemples: "char const ** str_arr", "char const * const * const str_arr".

 - *obviously* il faut que le code compile, qu’il n’y ait aucune fuite mémoire, aucun segfault, aucun crash, aucune boucle infinie inopinée.



II) Gestion des fichiers .h


A) Organisation générales des headers

 - Stdheader obligatoire.

 - Sauts de ligne uniques autorisés partout, et à utiliser à bon escient pour grouper.

 - Seules les inclusions de headers (système ou non), les déclarations, les defines, les prototypes et les macros sont autorisés dans les fichiers headers. Une inclusion de header (.h) dont on ne se sert pas est interdite.

 - Chaque module du code aura son propre fichier .h commenté et protégé contre la double-inclusion (macro témoin “FT_FOO_H” pour “ft_foo.h”).

 - Il n’y aura aucun commentaire sur une seule ligne dans un fichier .h.

 - Au sein d’un .h, on listera d’abord dans un premier bloc les préprocesseurs (includes puis defines), puis dans un second bloc les data structures, c’est-à-dire typedefs/struct/union/enums dans l’ordre convenant au module, puis enfin les signatures de fonction dans un bloc final. 

 - Triple saut de ligne entre le bloc des préprocesseurs et le bloc des datas structures. Triple saut de ligne entre le bloc des datas structures et le bloc des signatures de fonction.

 - Toute sous-section du .h sera précédée d'un commentaire rectangulaire en 3 lignes de 80 caractères chaque, imitant le style du rectangle du Stdheader. La ligne du milieu de ce commentaire sera le titre de la sous-section.



B) Le bloc préprocesseur

 - Les #define multilignes sont interdits.

 - Double-saut de ligne entre le bloc des #include et le bloc des #define au sein du bloc préprocesseur.

 - Autorisation des macros #define pour toute constante, notamment les struct constants du style “#define NULL_VEC2 ((t_vec2){0., 0.})” pour plus de lisibilité dans le code lui-même.

 - Autorisation des préprocesseurs #if, #ifdef uniquement pour définir une liste de constantes macro-defined et éventuellement de typedefs selon certaines conditions (notamment pour gérer les problématiques cross-platform, cf. plus bas).

 - Aucun autre cas d’utilisation de préprocesseur ne sera autorisé, en particulier une macro qui pourrait être plus proprement une fonction ‘inline’.

 - Indentation des préprocesseurs selon leur scope, non pas avec des espaces (# define), mais avec des tabulations (#   define).


C) Le bloc des data structures

 - Ce bloc commencera par la définition des globales éventuelles, précédé chacune d’un commentaire justifiant son usage.

 - Chaque struct/union/enum d’un fichier .h sera obligatoirement commenté (chaque attribut sera décrit pour un struct ou une union). Cela n’est pas requis pour un typedef, sauf si celui-ci n’est pas évident.

 - Le préprocesseur #ifdef/#endif peut être utilisé pour définir des typedef selon une macro. Ceci s'applique uniquement aux typedefs d'une seule ligne. Cela peut être utile pour gérer de la compilation cross-platform par exemple, ou pour définir un type 't_float' unique dans le code selon une macro conditionnelle '_FLOAT_32_' ou '_FLOAT_64_'. Toute telle utilisation de la macro #ifdef sera commentée.

 - Préfixe s_ pour un typedef de struct, e_ pour un typedef d'enum, u_ pour un typedef d’union, t_ pour un typedef basique, plutôt que t_ pour un typedef appliqué à un enum/union/struct. Toute structure de mémoire sera "typedefée" de manière appropriée avec le préfixe convenant (“typedef struct s_example_ {…} s_example;”).

 - Si un champ d’un struct est un pointeur sur fonction, ou juste qu’un type de pointeur sur fonction joue un rôle utile dans la structure de votre code, le type du pointeur sur fonction sera typedefé “f_[ftypename]”. Ftypename doit intelligemment décrire cette classe de fonctions. Le préfixe ‘f_’ est obligatoire.

 - Double-saut de ligne entre différents bloc thématiques de struct/union/enums/typedefs. L’utilisation d’un tel double-retour demande de commenter brièvement avant chaque sous-bloc pourquoi il est cohérent diviser l’ensemble ainsi (juste donner un bon nom à chaque sous-bloc, comme “RAYS & SHADERS” puis “CAMERA” peut convenir en guise de commentaire si cela rend claire la catégorisation).

 - Saut de ligne unique en haut ET en bas de chaque struct, union ou enum, sauf pour le dernier d'un bloc, qui sera suivi du double ou triple saut de ligne approprié.


D) Le bloc des signatures de fonction

 - Les signatures de fonctions dans le .h seront organisées selon les fichiers dans lesquels elle se trouvent, et un commentaire indiquant le nom du fichier .c auquel ces fonctions appartiennent les précédera. Si le fichier .c en question contient des fonctions statiques, leur signature sera mise dans le ce même commentaire. Une ligne vide dans ce commentaire séparera le nom du fichier.c de la liste de ses fonctions statiques.

 - Similairement à la division en sous-groupe des data structures, on se servira d’un double-saut de ligne entre chaque groupe de fonctions (ie, double saut de ligne après chaque groupe de fonctions, le dernier ne sera suivi que d’un saut de ligne, puis du #endif de la protection contre la double-inclusion). De même, chaque sous-groupe de fonctions sera précédé d’un commentaire expliquant la catégorisation. (“ALGEBRA FUNCTIONS“, puis “RENDERING FUNCTIONS” peut convenir.)

 - Pas de saut de ligne entre les signatures des fonctions d’un même fichier. Saut de ligne unique après une liste de fonctions d’un même fichier.



III) Fonctions et fichiers .c


A) Généralités

 - Stdheader obligatoire.

 - Prototypes de fonction interdits dans un .c.

 - Toute fonction qui n'est pas appelée autre part dans le code (que dans le fichier dans lequel elle se trouve) sera déclarée "static".

 - Inclusion uniquement du .h desquels dépendent les fonctions du fichier. Ce .h sera unique.

 - Vous ne pouvez pas déclarer un/une structure/union/enum/typedef dans un fichier .c.

 - Une fonction qui ne prend pas d’argument doit explicitement être prototypée avec le mot 'void' comme argument.


B) Lignes et espacements

 - Limitation du nombre de lignes par fichier .c à 250 (commentaires inclus), mais pas de limite sur le nombre de fonctions par fichier. Cela permet par exemple de faire des fonctions de toggle “void toggle(void)” nombreuses d’une ligne ou deux, dans un fichier unique “togglers.c”.

 - Nombre illimité de lignes par fonction, autorisation d’utiliser le whitespace au sein d’une ligne, et les retours à la ligne de manière libre, tant que cela rend le code plus lisible plutôt que moins. Pas d’espacements abusifs (pas de “multiple empty lines” au sein d’une fonction par exemple); mais encouragement à ‘sous-paragrapher’ les fonctions un peu plus complexes en les séparant avec une ligne vide unique entre chaque paragraphe. Tout paragraphe de fonction sera précédé d’un pseudocommentaire du style “/* description en deux-trois mots du paragraphe */“ sur une ligne à l’intérieur de la fonction, sans retour à la ligne après cette ligne de commentaire.

 - En contrepartie, le nombre d'instructions par fonction sera limité. Plutôt qu’un nombre de lignes limité à 25; on considère qu'une fonction peut monter jusqu'à 30/40 instructions par fonction (à discuter), et dans l'ensemble du code source, la moyenne d'instructions par fonction ne doit pas dépasser 15. C’est ce qui est recommandé pour le C de systèmes embarqués et pas mal d’experts en maintenabilité du code. C’est à la fois plus laxe, et plus contraignant que le critère de 25 lignes. Des logiciels d’analyse de code statique conviennent pour vérifier ceci.

 - Toute fonction de plus de 25 lignes (ne comptant pas les lignes vides), sera précédée d’un commentaire spécifiant le rôle de chaque argument, son fonctionnement et qui spécifiera aussi le rôle de cette fonction dans le reste du code.

 - Tout opérateur sera entouré de deux espaces vides (ex: “x >> 2”).

 - Une seule déclaration de variable par ligne (aucun “int a, b, c;” et surtout aucun “int *a, b, *c;”).


C) Outils du langage C autorisés

 - Autorisation des ‘for’ et ‘switch’ (quand même, l'absence de 'for' et de 'switch' fait un peut tâche quand on doit montrer son portfolio 42).

 - Interdiction des ternaires imbriqués. Interdiction d’utiliser une série de ternaires successifs quand un switch est approprié.

 - Interdiction des Variable Length Arrays. 

 - Tout cas nécessitant un ‘for’ et pas un ‘while’ utilisera un ‘for’, et pas un ‘while’. Tout cas nécessitant un ‘while’ et pas un ‘for’ utilisera un ‘while’, et pas un ‘for’.

 - Les ‘do … while’ seront autorisé UNIQUEMENT dans le cas où l’algorithme DOIT être lu au moins une seule fois et que la condition de la boucle ne peut pas encore être vérifiée pour un cas zéro. Ces boucles ne sont à utiliser qu’en cas d’extrême recours, et seront justifiée par un commentaire au-dessus de la fonction.

 - Un ‘switch’ ne sera utilisé que dans une situation où chaque 'case' est “symétrique” avec les autres (quasiment la même série d’opérations à quelques valeurs ou détails près). Des if/else en série seront utilisés dans le cas contraire. Dans les ‘switch’, il faudra aligner plusieurs instructions sur une seule ligne si elles sont courtes et que cela permet de mieux voir la symétrie des différents cas (cas du [x - 1]  [  x  ]  [x + 1] à aligner verticalement par exemple). Pensez à créer une sous-fonction ‘inline’ si jamais vous ne rentrez pas dans les 80 caractères par ligne.

 - Une seule instruction par ligne, version hard (jamais un ++ dans une ligne plus complexe, jamais de double assignation sur une seule ligne, etc), sauf éventuellement dans le cas d’un switch.

 - Post-incrémentation interdite (i++), uniquement pré-incrémentation autorisée (++i).

 - Autorisation des ‘goto’ selon les restrictions de la norme MISRA 2012: le 'goto' est autorisé uniquement si le label vers lequel le goto renvoie se trouve plus bas dans la même fonction que l’endroit où le goto est appelé. Le label sera judicieusement nommé. Cette technique a par exemple pour rôle de pouvoir break les uples-boucles (nested loops) lisiblement.

 - Interdiction d'utiliser malloc() après lancement d'un while(true) comme celui d’une graphics loop; sauf éventuellement pour un nombre de strings, linéaire par rapport au nombre de renders (ie, un n fixé de mallocs pour faire quelques strings de debug ou de log selon un template fixe par render, bien sûr libérés une fois utilisés avant le rendre suivant). Les objets nécessitant une large zone en mémoire ‘heap’ seront instanciés lors de l’initialisation du programme. Leur zone mémoire ne sera allouée qu’une fois, puis sera recyclée si besoin est, et ce jusqu’à la fin du programme, avant laquelle elle sera libérée. Pour des objets ayant besoin d’être créés lors d’un algorithme, instancier l’objet en mémoire ‘stack’ sans malloc est obligatoire.

 - Tout cas nécessitant un ‘while’, mais un while qui termine éventuellement (pas un while(true) de graphics loop) sera muni d’une borne supérieure adaptée. Atteindre cette borne supérieure fera quitter le programme proprement avec un message d’erreur convenable (“MODULE_FunctionGroup_FunctionThatCalledExitWithError: free ‘while’ loop limit exceeded”). Ceci peut être ignoré si une démonstration de l’algorithme est fournie en commentaire et que le code implémente clairement l'algorithme démontré

 - Limitation des tailles mémoires des arguments donnés à une fonction selon la mémoire disponible dans les registres (on peut avoir 5 arguments pour une fonction donnée si au moins deux d’entre eux sont des int32 si on a 4 registres de 64 bits). Savoir utiliser les struct en cas de besoin.

 - Plus de 5 variables locales sont autorisées par fonction. Cependant, si plus que la limite en taille mémoire des registres est utilisée, le mot clef ‘register’ doit être employé sur les variables qui ne doivent pas sortir des registres (itérateurs, typiquement). Si l’on a plus de 6 variables locales dans une fonction, celle-ci sera précédée d’un commentaire justifiant pourquoi (et expliquant éventuellement le rôle de chaque sous-groupe de variables locales).

- La somme des variables en input de fonction et de variables locales à la fonction ne doit jamais dépasser 12.




PS: suivre autant que possible la norme et l'esprit 42 pour le reste: même style de présentation/tabulations des struct/enum/union/typedef dans le .h; déclarations en début de fonction (éventuellement avec des sauts de lignes pour organiser les variables locales en sous-groupes); commentaires selon le même standard (commentaires multilignes formatés similairement, pas de C++ comment, mais droit au pseudocommentaire “/* titre de paragraphe */” en une ligne mentionnés ci-dessus); même règles de Makefile.


On souhaite avoir du code plus espacé et lisible, plus montrable en portfolio, ainsi qu’éviter de devoir ôter des accolades juste pour gagner des lignes ou gaver des lignes déjà complexes de ++ à tout va. Ca nous apprendrait des problématiques de C plus poussées niveau machine, notamment liées aux systèmes embarqués et aux OS, en faisant un entre-deux adapté et sérieux entre le code lisible et codable par des élèves de 42 et du code plus proche de ce qu’on trouve dans des normes professionnelles. Montrer qu’on est capable de coder dans 2 normes, et pas juste une seule, ça renforce la crédibilité d’être adaptable aussi.
